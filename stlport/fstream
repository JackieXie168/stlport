/*
 * Copyright (c) 1999
 * Silicon Graphics Computer Systems, Inc.
 *
 * Copyright (c) 1999
 * Boris Fomitchev
 *
 * This material is provided "as is", with absolutely no warranty expressed
 * or implied. Any use is at your own risk.
 *
 * Permission to use or copy this software for any purpose is hereby granted
 * without fee, provided the above notices are retained on all copies.
 * Permission to modify the code and to distribute modified code is granted,
 * provided the above notices are retained, and a notice that the code was
 * modified is included with the above copyright notice.
 *
 */


// This header defines classes basic_filebuf, basic_ifstream,
// basic_ofstream, and basic_fstream.  These classes represent
// streambufs and streams whose sources or destinations are files.

#ifndef _STLP_FSTREAM
#  define _STLP_FSTREAM

#ifndef _STLP_OUTERMOST_HEADER_ID
#  define _STLP_OUTERMOST_HEADER_ID 0x1025
#  include <stl/_prolog.h>
#  if defined (__DMC__) && defined (_DLL)
#    define _STLP_CLASS_IMPORT_DECLSPEC __declspec(dllimport)
#  endif
#endif

#ifndef _STLP_INTERNAL_STREAMBUF
#  include <stl/_streambuf.h>
#endif

#ifndef _STLP_INTERNAL_ISTREAM
#  include <stl/_istream.h>
#endif

#ifndef _STLP_INTERNAL_CODECVT_H
#  include <stl/_codecvt.h>
#endif

#if defined (_STLP_USE_UNIX_EMULATION_IO) || defined (_STLP_USE_STDIO_IO) || defined (_STLP_USE_UNIX_IO)
#ifndef _IORCNT
#define _IOWCNT _IOCNT
#define _IORCNT _IOCNT
#endif
typedef int _STLP_fd;
#else
#  error "Configure i/o !"
#endif

_STLP_BEGIN_NAMESPACE

//----------------------------------------------------------------------
// Class _Filebuf_base, a private base class to factor out the system-
// dependent code from basic_filebuf<>.

class _STLP_CLASS_DECLSPEC _Filebuf_base
{
public:                      // Opening and closing files.
  _Filebuf_base();

#ifdef _STLP_USE_STDIO_IO
  bool _M_open(FILE* __id, ios_base::openmode = ios_base::__default_mode);
#else
  bool _M_open(int __id, ios_base::openmode = ios_base::__default_mode);
#if defined (_STLP_USE_WIN32_IO)
  bool _M_open(_STLP_fd __id, ios_base::openmode = ios_base::__default_mode);
#endif /* _STLP_USE_WIN32_IO */
  void* _M_mmap(streamoff __offset, streamoff __len);
  void _M_unmap(void* __mmap_base, streamoff __len);
#endif

  bool _M_open(const char*, ios_base::openmode, int __protection);
  bool _M_open(const char*, ios_base::openmode);
  bool _M_close();

public:                      // Low-level I/O, like Unix read/write
  ptrdiff_t _M_read(char* __buf,  ptrdiff_t __n);
  streamoff _M_seek(streamoff __offset, ios_base::seekdir __dir);
  streamoff _M_file_size();
  bool _M_write(char* __buf,  ptrdiff_t __n);

  static void _S_initialize();

protected:                      // Static data members.
  static size_t _M_page_size;

  protected:
#if defined (_STLP_USE_STDIO_IO)
 public:
  bool _M_should_close;
  // for stdio, the whole FILE* is being kept here
  FILE* _M_file;
  bool __is_open() const { return _M_file != 0; } 
#else

public:
  // Returns a value n such that, if pos is the file pointer at the
  // beginning of the range [first, last), pos + n is the file pointer at
  // the end.  On many operating systems n == __last - __first.
  // In Unix, writing n characters always bumps the file position by n.
  // In Windows text mode, however, it bumps the file position by n + m,
  // where m is the number of newlines in the range.  That's because an
  // internal \n corresponds to an external two-character sequence.
  streamoff _M_get_offset(char* __first, char* __last) {
    return _M_in_binary_mode() ? (__last - __first)
      : count(__first, __last, '\n') + (__last - __first);
  }
  // Returns true if we're in binary mode or if we're using an OS or file
  // system where there is no distinction between text and binary mode.
#if defined (_STLP_UNIX) || defined (_STLP_MAC) || defined(__BEOS__) || defined (__amigaos__)
   bool _M_in_binary_mode() const { return true; }
#elif defined (_STLP_USE_STDIO_IO)
    bool _M_in_binary_mode() const;
#elif defined (_STLP_WIN32) || defined (_STLP_VM)
    bool _M_in_binary_mode() const {
      return (_M_openmode & ios_base::binary) != 0;
    }
#else
#  error "Port!"
#endif
  
  _STLP_fd _M_file_id;
  ios_base::openmode _M_openmode;
  
  enum {
    _is_open = 0x1,
    _should_close = 0x2,
    _regular = 0x4
  };

#if defined (_STLP_USE_WIN32_IO)
    _STLP_fd _M_view_id;
#endif

#endif
};

//----------------------------------------------------------------------
// Class basic_filebuf<>.

// Forward declaration of two helper classes.
template <class _Traits> class _Noconv_input;
template <class _Traits> class _Noconv_output;

// There is a specialized version of underflow, for basic_filebuf<char>,
// in fstream.cpp.
template <class _CharT, class _Traits>
class _Underflow;

template <class _CharT, class _Traits>
class basic_filebuf : public basic_streambuf<_CharT, _Traits> {
public:                         // Types.
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;

  typedef typename _Traits::state_type _State_type;
  typedef basic_streambuf<_CharT, _Traits> _Base;
  typedef basic_filebuf<_CharT, _Traits> _Self;

public:                         // Constructors, destructor.
#ifdef _STLP_USE_STDIO_IO
  basic_filebuf(FILE* __f) {_Init(__f, _InitReasonNew);}
#endif
  basic_filebuf();
  ~basic_filebuf();

public:                         // Opening and closing files.
  bool is_open() const { return _M_base.__is_open(); }

  _Self* open(const char* __s, ios_base::openmode __m) {
    if ( _M_base._M_open(__s, __m)) {
      _M_init();
      return this;
    } else
      return 0;
  }

  // These two version of open() and file descriptor getter are extensions.
  _Self* open(const char* __s, ios_base::openmode __m,
              int __protection) {
    if (_M_base._M_open(__s, __m, __protection)) {
      _M_init();
      return this;
    } else
      return 0;
  }

#  ifdef _STLP_USE_STDIO_IO

  void _M_init() { _Init(_M_base._M_file); }
  _Self* open(FILE* __id, ios_base::openmode _Init_mode = ios_base::__default_mode) {
    _M_base._M_open(__id, _Init_mode);
    _Init(_M_base._M_file);
    return this;
  }
  enum _Initfl { _InitReasonNew = 0, _InitReasonOpen = 1, _InitReasonClose = 2 };
  void _Init(FILE *_F, _Initfl _M_reason = _InitReasonOpen);

#else

  _STLP_fd fd() const { return _M_base.__get_fd(); }

  void _M_init() {  }

  // Precondition: we are currently in putback input mode.  Effect:
  // switches back to ordinary input mode.
  void _M_exit_putback_mode()
  {
    this->setg(_M_saved_eback, _M_saved_gptr, _M_saved_egptr);
    int_flags_ &= ~_in_putback_mode;
  }
  
#  if defined (_STLP_USE_WIN32_IO)
  _Self* open(_STLP_fd __id, ios_base::openmode _Init_mode = ios_base::__default_mode) {
    return _M_base._M_open(__id, _Init_mode) ? this : 0;
  }
#  endif /* _STLP_USE_WIN32_IO */
  _Self* open(int __id, ios_base::openmode _Init_mode = ios_base::__default_mode) {
    return this->_M_open(__id, _Init_mode);
  }
  _Self* _M_open(int __id, ios_base::openmode _Init_mode = ios_base::__default_mode) {
    return _M_base._M_open(__id, _Init_mode) ? this : 0;
  }
#  endif
  _Self* close();

protected:                      // Virtual functions from basic_streambuf.

  virtual int_type underflow();
  virtual int_type uflow();

  virtual int_type pbackfail(int_type = traits_type::eof());
  virtual int_type overflow(int_type = traits_type::eof());

  virtual basic_streambuf<_CharT, _Traits>* setbuf(char_type*, streamsize);
  virtual pos_type seekoff(off_type, ios_base::seekdir,
                           ios_base::openmode = ios_base::in | ios_base::out);
  virtual pos_type seekpos(pos_type,
                           ios_base::openmode = ios_base::in | ios_base::out);

  virtual int sync();
  virtual void imbue(const locale&);

public:
  bool _M_write(char* __buf,  ptrdiff_t __n) {return _M_base._M_write(__buf, __n); }

private:                        // Data members used in all modes.
  typedef codecvt<_CharT, char, _State_type> _Codecvt;

#if defined (_STLP_USE_STDIO_IO)
  const _Codecvt* _M_codecvt;
  _CharT      _M_pback_buf;
  bool        _M_dirty_buf;
  _State_type _M_state;
#endif

  _Filebuf_base _M_base;

 public:
#if defined (_STLP_USE_STDIO_IO)
  bool _Endwrite();
  void _Initcvt(_Codecvt* __c);
  bool __is_open() const  { return _M_base._M_file != 0; }
  int __get_fd() const { return _fileno(_M_base._M_file); }
#else
  static size_t _STLP_CALL __page_size() { return _M_page_size; }
  int __o_mode() const { return (int)_M_openmode; }
  bool __is_open() const { return (int_flags_ & _is_open) != 0; }
  bool __regular_file() const { return (int_flags_ & _regular) != 0; }
  _STLP_fd __get_fd() const { return _M_file_id; }
  int_type
  _M_do_noconv_input() {
    _M_ext_buf_converted = _M_ext_buf_end;
    /* this-> */ _Base::setg((char_type*)_M_ext_buf, (char_type*)_M_ext_buf, (char_type*)_M_ext_buf_end);
    return traits_type::to_int_type(*_M_ext_buf);
  }
#endif
  
#if !defined (_STLP_USE_STDIO_IO)

private:                        // Helper functions.
  bool _M_switch_to_input_mode();
  void _M_exit_input_mode();
  bool _M_switch_to_output_mode();
  int_type _M_input_error();
  int_type _M_underflow_aux();
  friend class _Underflow<_CharT, _Traits>;
  int_type _M_output_error();
  bool _M_unshift();
  bool _M_allocate_buffers(_CharT* __buf, streamsize __n);
  bool _M_allocate_buffers();
  void _M_deallocate_buffers();
  bool _M_seek_init(bool __do_unshift);
  void _M_setup_codecvt(const locale&, bool __on_imbue = true);
  pos_type _M_seek_return(off_type __off, _State_type __state);
  
  enum {
      _constant_width  = 0x1,
      _always_noconv   = 0x2,
      _int_buf_dynamic = 0x4, // set if internal buffer is heap allocated,
                              // unset if it was supplied by the user;
      _in_input_mode   = 0x8,
      _in_output_mode  = 0x10,
      _in_error_mode   = 0x20,
      _in_putback_mode = 0x40
    };

    unsigned int_flags_;

  // Internal buffer: characters seen by the filebuf's clients.
  _CharT* _M_int_buf;
  _CharT* _M_int_buf_EOS;

  // External buffer: characters corresponding to the external file.
  char* _M_ext_buf;
  char* _M_ext_buf_EOS;

  // The range [_M_ext_buf, _M_ext_buf_converted) contains the external
  // characters corresponding to the sequence in the internal buffer.  The
  // range [_M_ext_buf_converted, _M_ext_buf_end) contains characters that
  // have been read into the external buffer but have not been converted
  // to an internal sequence.
  char* _M_ext_buf_converted;
  char* _M_ext_buf_end;

  // State corresponding to beginning of internal buffer.
  _State_type _M_state;

private:                        // Data members used only in input mode.
  // Similar to _M_state except that it corresponds to
  // the end of the internal buffer instead of the beginning.
  _State_type _M_end_state;
  // This is a null pointer unless we are in mmap input mode.
  void*     _M_mmap_base;
  streamoff _M_mmap_len;

private:                        // Data members used only in putback mode.
  _CharT* _M_saved_eback;
  _CharT* _M_saved_gptr;
  _CharT* _M_saved_egptr;

  const _Codecvt* _M_codecvt;

  int _M_width;                 // Width of the encoding (if constant), else 1
  int _M_max_width;             // Largest possible width of single character.

  enum { _S_pback_buf_size = 8 };
  _CharT _M_pback_buf[_S_pback_buf_size];

#endif

};

#ifdef __SUNPRO_CC
// Suppress warning that a derived class' rdbuf() hides basic_ios::rdbuf
#pragma disable_warn
#endif

//----------------------------------------------------------------------
// Class basic_ifstream<>

template <class _CharT, class _Traits>
class basic_ifstream : public basic_istream<_CharT, _Traits> {
public:                         // Types
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;

  typedef basic_ios<_CharT, _Traits>                _Basic_ios;
  typedef basic_istream<_CharT, _Traits>            _Base;
  typedef basic_filebuf<_CharT, _Traits>            _Buf;

public:                         // Constructors, destructor.

  basic_ifstream() : basic_ios<_CharT, _Traits>(),  basic_istream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
  }
  
  explicit basic_ifstream(const char* __s, ios_base::openmode __mod = ios_base::in) :
    basic_ios<_CharT, _Traits>(),  basic_istream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__s, __mod | ios_base::in))
      this->setstate(ios_base::failbit);
  }
  
#ifdef _STLP_USE_STDIO_IO
  explicit basic_ifstream(FILE* __f): basic_ios<_CharT, _Traits>(),  basic_istream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    // todo : set mode according to mode of __f
    if (!_M_buf.open(__f, ios_base::in))
      this->setstate(ios_base::failbit);
  }
#else
  explicit basic_ifstream(int __id, ios_base::openmode __mod = ios_base::in) :
    basic_ios<_CharT, _Traits>(),  basic_istream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__id, __mod | ios_base::in))
      this->setstate(ios_base::failbit);
  }
#endif

  basic_ifstream(const char* __s, ios_base::openmode __m, int __protection) :
    basic_ios<_CharT, _Traits>(),  basic_istream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__s, __m | ios_base::in, __protection))
      this->setstate(ios_base::failbit);
  }
  
#  if defined (_STLP_USE_WIN32_IO)
  explicit basic_ifstream(_STLP_fd __id, ios_base::openmode __mod = ios_base::in) :
    basic_ios<_CharT, _Traits>(),  basic_istream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__id, __mod | ios_base::in))
      this->setstate(ios_base::failbit);
  }
#  endif /* _STLP_USE_WIN32_IO */

  ~basic_ifstream() {}

public:                         // File and buffer operations.
  basic_filebuf<_CharT, _Traits>* rdbuf() const { return __CONST_CAST(_Buf*,&_M_buf); }
  bool is_open() const { return this->rdbuf()->is_open(); }
  void open(const char* __s, ios_base::openmode __mod = ios_base::in) {
    if (!this->rdbuf()->open(__s, __mod | ios_base::in))
      this->setstate(ios_base::failbit);
  }

  void close() {
    if (!this->rdbuf()->close())
      this->setstate(ios_base::failbit);
  }

private:
  basic_filebuf<_CharT, _Traits> _M_buf;
};


//----------------------------------------------------------------------
// Class basic_ofstream<>

template <class _CharT, class _Traits>
class basic_ofstream : public basic_ostream<_CharT, _Traits> {
public:                         // Types
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;

  typedef basic_ios<_CharT, _Traits>                _Basic_ios;
  typedef basic_ostream<_CharT, _Traits>            _Base;
  typedef basic_filebuf<_CharT, _Traits>            _Buf;

public:                         // Constructors, destructor.
  basic_ofstream() : basic_ios<_CharT, _Traits>(), basic_ostream<_CharT, _Traits>(0), _M_buf() {
      this->init(&_M_buf);
  }
  explicit basic_ofstream(const char* __s, ios_base::openmode __mod = ios_base::out)
    : basic_ios<_CharT, _Traits>(), basic_ostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__s, __mod | ios_base::out))
      this->setstate(ios_base::failbit);
  }

#ifdef _STLP_USE_STDIO_IO
  explicit basic_ofstream(FILE* __f):
    basic_ios<_CharT, _Traits>(),  basic_ostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    // todo : set mode according to mode of __f
    if (!_M_buf.open(__f, ios_base::out))
      this->setstate(ios_base::failbit);
  }
#else
  explicit basic_ofstream(int __id, ios_base::openmode __mod = ios_base::out) :
    basic_ios<_CharT, _Traits>(), basic_ostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__id, __mod | ios_base::out))
      this->setstate(ios_base::failbit);
  }
#endif

  basic_ofstream(const char* __s, ios_base::openmode __m, int __protection) :
    basic_ios<_CharT, _Traits>(),  basic_ostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__s, __m | ios_base::out, __protection))
      this->setstate(ios_base::failbit);
  }
#  if defined (_STLP_USE_WIN32_IO)
  explicit basic_ofstream(_STLP_fd __id, ios_base::openmode __mod = ios_base::out)
    : basic_ios<_CharT, _Traits>(), basic_ostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__id, __mod | ios_base::out))
      this->setstate(ios_base::failbit);
  }
#  endif /* _STLP_USE_WIN32_IO */

  ~basic_ofstream() {}

public:                         // File and buffer operations.
  basic_filebuf<_CharT, _Traits>* rdbuf() const { return __CONST_CAST(_Buf*,&_M_buf); }

  bool is_open() const { return this->rdbuf()->is_open(); }

  void open(const char* __s, ios_base::openmode __mod= ios_base::out) {
    if (!this->rdbuf()->open(__s, __mod | ios_base::out))
      this->setstate(ios_base::failbit);
  }

  void close() {
    if (!this->rdbuf()->close())
      this->setstate(ios_base::failbit);
  }

private:
  basic_filebuf<_CharT, _Traits> _M_buf;
};


//----------------------------------------------------------------------
// Class basic_fstream<>

template <class _CharT, class _Traits>
class basic_fstream : public basic_iostream<_CharT, _Traits> {
public:                         // Types
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;

  typedef basic_ios<_CharT, _Traits>                _Basic_ios;
  typedef basic_iostream<_CharT, _Traits>           _Base;
  typedef basic_filebuf<_CharT, _Traits>            _Buf;

public:                         // Constructors, destructor.

  basic_fstream(): basic_ios<_CharT, _Traits>(), basic_iostream<_CharT, _Traits>(0), _M_buf() {
      this->init(&_M_buf);
  }

  explicit basic_fstream(const char* __s,
                         ios_base::openmode __mod = ios_base::in | ios_base::out) :
    basic_ios<_CharT, _Traits>(), basic_iostream<_CharT, _Traits>(0), _M_buf() {
      this->init(&_M_buf);
      if (!_M_buf.open(__s, __mod))
        this->setstate(ios_base::failbit);
  }
#ifdef _STLP_USE_STDIO_IO
  explicit basic_fstream(FILE* __f) :
    basic_ios<_CharT, _Traits>(),  basic_iostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    // todo : set mode according to mode of __f
    if (!_M_buf.open(__f, ios_base::in|ios_base::out ))
      this->setstate(ios_base::failbit);
  }
#else
  explicit basic_fstream(int __id,
                         ios_base::openmode __mod = ios_base::in | ios_base::out) :
    basic_ios<_CharT, _Traits>(), basic_iostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__id, __mod))
      this->setstate(ios_base::failbit);
  }
#endif
  basic_fstream(const char* __s, ios_base::openmode __m, int __protection) :
    basic_ios<_CharT, _Traits>(),  basic_iostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__s, __m, __protection))
      this->setstate(ios_base::failbit);
  }

#  if defined (_STLP_USE_WIN32_IO)
  explicit basic_fstream(_STLP_fd __id,
    ios_base::openmode __mod = ios_base::in | ios_base::out) :
    basic_ios<_CharT, _Traits>(),  basic_iostream<_CharT, _Traits>(0), _M_buf() {
    this->init(&_M_buf);
    if (!_M_buf.open(__id, __mod))
      this->setstate(ios_base::failbit);
  }
#  endif /* _STLP_USE_WIN32_IO */

  ~basic_fstream() {}

public:                         // File and buffer operations.

  basic_filebuf<_CharT, _Traits>* rdbuf() const  { return __CONST_CAST(_Buf*, &_M_buf); }

  bool is_open() const { return this->rdbuf()->is_open(); }

  void open(const char* __s, ios_base::openmode __mod = ios_base::in | ios_base::out) {
    if (!this->rdbuf()->open(__s, __mod))
      this->setstate(ios_base::failbit);
  }
  
  void close() {
    if (!this->rdbuf()->close())
      this->setstate(ios_base::failbit);
  }

private:
  basic_filebuf<_CharT, _Traits> _M_buf;

#if defined (_STLP_MSVC) && (_STLP_MSVC >= 1300 && _STLP_MSVC <= 1310)
  typedef basic_fstream<_CharT, _Traits> _Self;
  //explicitely defined as private to avoid warnings:
  basic_fstream(_Self const&);
  _Self& operator = (_Self const&);
#endif
};

#ifdef __SUNPRO_CC
#pragma enable_warn
#endif

_STLP_END_NAMESPACE

#if defined (_STLP_EXPOSE_STREAM_IMPLEMENTATION)
#ifdef _STLP_USE_STDIO_IO
#  include <stl/_fstream_stdio.c>
#else
#  include <stl/_fstream.c>
#endif
#endif

_STLP_BEGIN_NAMESPACE

#if defined (_STLP_USE_TEMPLATE_EXPORT)
_STLP_EXPORT_TEMPLATE_CLASS basic_filebuf<char, char_traits<char> >;
_STLP_EXPORT_TEMPLATE_CLASS basic_ifstream<char, char_traits<char> >;
_STLP_EXPORT_TEMPLATE_CLASS basic_ofstream<char, char_traits<char> >;
_STLP_EXPORT_TEMPLATE_CLASS basic_fstream<char, char_traits<char> >;
#  if ! defined (_STLP_NO_WCHAR_T)
_STLP_EXPORT_TEMPLATE_CLASS basic_filebuf<wchar_t, char_traits<wchar_t> >;
_STLP_EXPORT_TEMPLATE_CLASS basic_ifstream<wchar_t, char_traits<wchar_t> >;
_STLP_EXPORT_TEMPLATE_CLASS basic_ofstream<wchar_t, char_traits<wchar_t> >;
_STLP_EXPORT_TEMPLATE_CLASS basic_fstream<wchar_t, char_traits<wchar_t> >;
#  endif
#endif /* _STLP_USE_TEMPLATE_EXPORT */

_STLP_END_NAMESPACE

#if (_STLP_OUTERMOST_HEADER_ID == 0x1025)
#  include <stl/_epilog.h>
#  undef _STLP_OUTERMOST_HEADER_ID
#  if defined (__DMC__) && defined (_DLL)
#    undef _STLP_CLASS_IMPORT_DECLSPEC
#    define _STLP_CLASS_IMPORT_DECLSPEC
#  endif
#endif

#endif /* _STLP_FSTREAM */

// Local Variables:
// mode:C++
// End:
